import argparse
import re
import os
import glob
import datetime
import time
import numpy as np
import torch
import torch.nn as nn
import h5py
from scipy import io
from utils import *
from models import *
import torch.optim as optim
from torch.optim.lr_scheduler import MultiStepLR
# Params
parser = argparse.ArgumentParser(description='PyTorch Complex DnCNN')
parser.add_argument(
    '--model',
    default='cDnCNN',
    type=str,
    help='choose a type of model')
parser.add_argument('--batch_size', default=6, type=int, help='batch size')
parser.add_argument('--train_data',
                    default='channel',
                    type=str,
                    help='path of train data')
parser.add_argument('--snr', default=5, type=int, help='noise level')
parser.add_argument('--channel_clusters', default=6,
                    type=int, help='clusters of channel')
parser.add_argument('--paths_per_cluster', default=8,
                    type=int, help='paths per cluster')
parser.add_argument('--angle_spread', default=7.5,
                    type=int, help='angle spread')
parser.add_argument('--epoch',
                    default=150,
                    type=int,
                    help='number of train epoches')
parser.add_argument('--lr',
                    default=1e-4,
                    type=float,
                    help='initial learning rate for Adam')
args = parser.parse_args()
clusters = args.channel_clusters
paths = args.paths_per_cluster
AS = args.angle_spread
batch_size = args.batch_size
train_data = args.train_data
cuda = torch.cuda.is_available()
print(cuda)
n_epoch = args.epoch
snr = args.snr
# snr = 10
save_dir = os.path.join('models', args.model + '_' + 'snr' + str(snr))
if not os.path.exists(save_dir):
    os.mkdir(save_dir)

if __name__ == '__main__':

    print('>>> Building Model')
    model = ComplexDnCNN().cuda()
    # uncomment to use dataparallel (unstable)
    # device_ids = [0, 1]
    # model = nn.DataParallel(model, device_ids=device_ids).cuda()

    initial_epoch = findLastCheckpoint(save_dir=save_dir)
    if initial_epoch > 0:
        print('resuming by loading epoch %03d' % initial_epoch)
        model.load_state_dict(
            torch.load(os.path.join(save_dir,
                                    'model_%03d.pth' % initial_epoch)))
    print(">>> Building Model Finished")
    model.train()  # Enable BN and Dropout
    criterion = nn.MSELoss(reduction='sum').cuda()
    optimizer = optim.Adam(model.parameters(), lr=args.lr)
    scheduler = MultiStepLR(optimizer, milestones=[20, 40, 60, 80, 100, 120],
                            gamma=0.5)  # learning rates
    print("Loading Data")
    # should be generated by yourself
    train_est = train_data + '/' + \
        str(snr)+'dB/trainingChannel'+str(snr) + \
        '_C' + str(clusters) + 'P' + str(paths) + '_AS' + str(AS) + '.mat'

    train_true = train_data + '/' + \
        str(snr)+'dB/trueTrainingChannel'+str(snr) + \
        '_C' + str(clusters) + 'P' + str(paths) + '_AS' + str(AS) + '.mat'

    train_est_mat = h5py.File(train_est, mode='r')
    # print(train_est_mat.keys())
    x_train = train_est_mat['trainingChannel']
    x_train = np.transpose(x_train, [3, 2, 1, 0])
    print('>>> training Set setup complete')

    # ground truth
    train_true_mat = h5py.File(train_true, mode='r')
    # y_train = train_true_mat['trueTrainingChannel']
    y_train = train_true_mat['trueTrainingChannel']
    y_train = np.transpose(y_train, [3, 2, 1, 0])
    print('>>> groundTruth Set setup complete')

    x_train = torch.from_numpy(x_train).float().reshape(
        [x_train.shape[0], x_train.shape[1], 1, x_train.shape[2], x_train.shape[3]])
    # x_train = x_train[0:2000, :]
    print(x_train.shape)
    y_train = torch.from_numpy(y_train).float().reshape(
        [y_train.shape[0], y_train.shape[1], 1, y_train.shape[2], y_train.shape[3]])
    print(y_train.shape)
    DDataset = MyDenoisingDataset(y_train, x_train)
    DLoader = DataLoader(dataset=DDataset,
                             num_workers=4,
                             drop_last=True,
                             batch_size=batch_size,
                             shuffle=True)
    for epoch in range(initial_epoch, n_epoch):
        epoch_loss = 0
        start_time = time.time()
        for n_count, batch_yx in enumerate(DLoader):
            optimizer.zero_grad()
            if cuda:
                batch_x, batch_y = batch_yx[1].cuda(), batch_yx[0].cuda()
            loss = criterion(model(batch_y), batch_x)
            epoch_loss += loss.item()
            loss.backward()
            optimizer.step()
            scheduler.step(epoch)  # step to the learning rate in this epoch
            if n_count % 10 == 0:
                print('%4d %4d / %4d loss = %2.4f\t' %
                      (epoch + 1, n_count, x_train.size(0) // batch_size,
                       loss.item() / batch_size))
        elapsed_time = time.time() - start_time
        log('epoch = %4d , loss = %4.4f , time = %4.2f s' %
            (epoch + 1, epoch_loss / n_count, elapsed_time))
        torch.save(model.state_dict(),
                   os.path.join(save_dir, 'model_%03d.pth' % (epoch + 1)))
        # torch.save(model, os.path.join(save_dir, 'model_%03d.pth' % (epoch+1)))
